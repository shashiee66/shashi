/*****************************************************************************/
/* Triangle MicroWorks, Inc.                         Copyright (c) 1997-2020 */
/*****************************************************************************/
/*                                                                           */
/* This file is the property of:                                             */
/*                                                                           */
/*                       Triangle MicroWorks, Inc.                           */
/*                      Raleigh, North Carolina USA                          */
/*                       www.TriangleMicroWorks.com                          */
/*                          (919) 870-6615                                   */
/*                                                                           */
/* This Source Code and the associated Documentation contain proprietary     */
/* information of Triangle MicroWorks, Inc. and may not be copied or         */
/* distributed in any form without the written permission of Triangle        */
/* MicroWorks, Inc.  Copies of the source code may be made only for backup   */
/* purposes.                                                                 */
/*                                                                           */
/* Your License agreement may limit the installation of this source code to  */
/* specific products.  Before installing this source code on a new           */
/* application, check your license agreement to ensure it allows use on the  */
/* product in question.  Contact Triangle MicroWorks for information about   */
/* extending the number of products that may use this source code library or */
/* obtaining the newest revision.                                            */
/*                                                                           */
/*****************************************************************************/

/* file: dnpchnl.h
 * description: DNP3 Channel Implementation.
 */
#ifndef DNPCHNL_DEFINED
#define DNPCHNL_DEFINED

#include "tmwscl/utils/tmwappl.h"
#include "tmwscl/utils/tmwchnl.h"
#include "tmwscl/utils/tmwphys.h"

#include "tmwscl/dnp/dnplink.h"
#include "tmwscl/dnp/dnptprt.h"
#include "tmwscl/dnp/dnpbncfg.h"

/* Arbitrary magic number, to indicate if TMWSESN_TX_DATA structure has
 * been allocated or deallocated
 */
#define DNPCHNL_TXDATA_VALID 0x5555

 /* Default priorities for Tx Data */
#define DNPCHNL_DEFAULT_PRIORITY 128
#define DNPCHNL_DEFAULT_AUTH_PRIORITY 251

/* Define support for user response callbacks. The user can specify a user
 * callback when requests are generated by calling the various request
 * functions defined in mdnpbrm.h. This callback will be called to alert
 * the user to the the current status of the request. As described in
 * mdnpbrm.h most requests will consist of a single request/response in
 * which case the user callback will be called once with either a success
 * status or one of the failure status codes. Some requests require multiple
 * request/response cycles in which case the user callback will get called
 * one or more times with an intermediate response status. The request is
 * complete when the response status is success or a failure code.
 */
typedef enum DNPChannelRespStatus {
  
  /* This indicates the request has completed successfully.
   */
  DNPCHNL_RESP_STATUS_SUCCESS = 0,

  /* This indicates a response was received but the requested command is 
   * not yet complete. This could mean the response is part of a multi-fragment
   * response and did not have the FINAL bit set. Or this could be a request such
   * as a select operate that requires multiple requests and responses.
   */
  DNPCHNL_RESP_STATUS_INTERMEDIATE,

  /* This indicates that the transmission of the request failed 
   */
  DNPCHNL_RESP_STATUS_FAILURE,

  /* The response to a select or an execute did not echo the request 
   */
  DNPCHNL_RESP_STATUS_MISMATCH,

  /* The response to a select or an execute echoed the request, except the
   * status code was different indicating a failure. 
   */
  DNPCHNL_RESP_STATUS_STATUSCODE,

  /* The response to the request had IIN bits set indicating the command failed.
   *
   */
   DNPCHNL_RESP_STATUS_IIN,

  /* This indicates that the request has timed out. This could either be an 
   * incremental timeout indicating we received no link layer frame from the 
   * device in the specified time, or an application response timeout indicating
   * this particular request did not complete in the specified time.
   */
  DNPCHNL_RESP_STATUS_TIMEOUT,

  /* This indicates either that the user asked that the request be canceled by
   * calling dnpchnl_cancelFragment or that a second duplicate request has been
   * made and therefore this first one is canceled.
   */
  DNPCHNL_RESP_STATUS_CANCELED
} DNPCHNL_RESP_STATUS;

/* Structure which contains the information passed to the user code in the
 * user callback. 
 *  last - TMWDEFS_TRUE if this is the last time the callback will be called
 *   for this request.
 *  pSession - session request was issued to
 *  iin - State of the Internal Indication Bits in the response
 *  status - response status
 *  requestStatus - request specific status information
 *  responseTime - time between when command was sent and response received 
 *  pTxData - pointer to original request transmit data structure returned 
 *   by the call to the mdnpbrm request function which generated the request.
 *  pRxData - pointer to received response data structure or TMWDEFS_NULL if
 *   no response.
 */
typedef struct DNPChannelResponseStruct {
  TMWTYPES_BOOL last;
  TMWSESN *pSession;
  TMWTYPES_USHORT iin;
  DNPCHNL_RESP_STATUS status;
  TMWTYPES_UCHAR requestStatus;
  TMWTYPES_MILLISECONDS responseTime;
  TMWSESN_TX_DATA *pTxData;
  TMWSESN_RX_DATA *pRxData;
} DNPCHNL_RESPONSE_INFO;

/* Define the response callback function.
 */
typedef void (*DNPCHNL_CALLBACK_FUNC)(
  void *pCallbackParam,
  DNPCHNL_RESPONSE_INFO *pResponse);

/* DNP Specific tx flags */
#define DNPCHNL_DNPTXFLAGS_AUTH_NOACKDELAY     0x0001

typedef struct DNPChannelTransDataStruct {
  /* Generic TMW data structure, must be first entry */
  TMWSESN_TX_DATA tmw;

  /* DNP Specific tx flags */
  TMWTYPES_ULONG dnpTxFlags;

  /* Has this request been sent */
  TMWTYPES_BOOL sent;

  /* Priority of this request */
  TMWTYPES_UCHAR priority;
   
  TMWTYPES_UCHAR referenceCount;

  /* User number to use for secure authentication 
   * if aggressive mode is selected or outstation challenges this request
   */
  TMWTYPES_USHORT authUserNumber;
  TMWTYPES_UCHAR  authAggrModeObjLength;
  TMWTYPES_BOOL   authAggressiveMode;

  /* Internal callback */
  void *pInternalCallbackParam;
  DNPCHNL_CALLBACK_FUNC pInternalCallback;

  /* User callback */
  void *pUserCallbackParam;
  DNPCHNL_CALLBACK_FUNC pUserCallback;
   
#if !TMWCNFG_USE_DYNAMIC_MEMORY || TMWCNFG_ALLOC_ONLY_AT_STARTUP 
  /* Buffer to hold the message to be transmitted */
  TMWTYPES_UCHAR buffer[DNPCNFG_MAX_TX_FRAGMENT_LENGTH];
#endif

} DNPCHNL_TX_DATA;

/* DNP3 Channel configuration structure. This structure contains 
 * configuration parameters that are specific to a DNP3 channel. 
 */
typedef struct {

  /* Maximum receive and transmit application fragment sizes
   *  The DNP3 specification recommends a value of 2048.
   */
  TMWTYPES_USHORT        rxFragmentSize;
  TMWTYPES_USHORT        txFragmentSize;

  /* Removed rxFrameSize and txFrameSize. 
   * To configure frame sizes set
   *  DNPLINK_CONFIG txFrameSize and rxFrameSize 
   */

  /* Maximum number of request messages that will be queued on a DNP3 master 
   * Setting this to 0 allows an unlimited number of requests to be queued.
   * Setting this to 1 allows only 1 outstanding request at a time,
   * Setting this to a number greater than 1 specifies that number of 
   *   outstanding and queued requests
   * NOTE: MDNP session auto generation of requests requires more than 
   *  1 request to be queued. If setting maxQueueSize to 1 you should
   *  set MDNP session autoRequestMask to 0.
   */
  TMWTYPES_USHORT        maxQueueSize;

  /* For a DNP master how long to wait for a response to a request that has  
   * actually been transmitted.
   * This value can be made shorter than the 
   * MDNPSESN_CONFIG defaultResponseTimeout 
   * to quickly determine if a particular device is not responding, without 
   * causing requests to other devices on the same channel to also time out.
   * NOTE: This is not used by a DNP slave.
   */
  TMWTYPES_MILLISECONDS  channelResponseTimeout;

  /* For a DNP master how long to delay sending a request to offline sessions.
   * This may allow other online sessions on that channel to communicate better. 
   * When this time expires, a queued request will be attempted to an offline session. 
   * If that request times out the next request for an offline session may be delayed
   * again by this amount of time. The number of sessions on a channel and the
   * channelResponseTimeout should be considered when setting this value. For this
   * to have an affect it needs to be larger than channelResponseTimeout. The 
   * longer this delay, the longer it might take to detect a session could respond. 
   * Other responses such as link layer or unsolicited responses may also bring 
   * the session online.
   */
  TMWTYPES_MILLISECONDS  channelOffLineDelay;

  /* routine to call when events occur on this channel,
   *   can be used to track statistics on this channel.
   */
  TMWCHNL_STAT_CALLBACK  pStatCallback;

  /* user callback parameter to pass to pStatCallback 
   */
  void                  *pStatCallbackParam;

  /* routine to call when channel becomes idle. That is there are
   * no commands queued to be sent out, none being transmitted, 
   * and there are no responses or confirms expected back.
   * This can be used to provide support for modem pools, 
   * allowing the user to know when it is safe to disconnect
   * the line from the SCLs point of view.
   */
  TMWCHNL_IDLE_CALLBACK  pIdleCallback;

  /* user callback parameter to pass to pIdleCallback 
   */
  void                  *pIdleCallbackParam;

  /* routine to call when a message has been received for a session that is
   * not currently open. This user provided function can determine whether or
   * not to open the session and allow the received message to be processed.
   * For details on this see definition of TMWCHNL_AUTO_OPEN_FUNC in tmwchnl.h
   */
  TMWCHNL_AUTO_OPEN_FUNC  pAutoOpenCallback;

  /* user callback parameter to pass to pAutoOpenCallback 
   */
  void                   *pAutoOpenCallbackParam;

  /* Mask for disabling generation of diagnostic strings */
  TMWTYPES_ULONG         chnlDiagMask;

} DNPCHNL_CONFIG;

/* Define context for a DNP3 specific channel. This structure is for internal
 * TMW SCL use only.
 */
typedef struct {

  /* Define generic TMW channel, must be first entry */
  TMWCHNL tmw;

  /* To round robin between sessions */
  TMWSESN *pLastSessionRequest;
  TMWSESN *pLastOfflineSessionRequest;

  /* Maximum size for a transmit fragment */
  TMWTYPES_USHORT txFragmentSize; 

  /* Maximum size for a receive fragment */
  TMWTYPES_USHORT rxFragmentSize; 

  /* To delay sending requests to offline sessions if configured */
  TMWTYPES_MILLISECONDS  channelOffLineDelay;
  TMWTIMER channelOffLineDelayTimer;

#if DNPCNFG_SUPPORT_AUTHENTICATION
  /* Used only on master with secure authentication, 
   * delay this long to see if a challenge is received
   * when sending non broadcast direct operate noack commands.
   */
  TMWTYPES_MILLISECONDS directNoAckDelayTime;

#if !DNPCNFG_MULTI_SESSION_REQUESTS
  TMWTYPES_USHORT lastTxFragmentLength;
  TMWTYPES_USHORT lastUnsolTxFragmentLength;
  /* lastUnsolTxFragment is only required if there is a slave session on this channel
   * This could be removed if only supporting master sessions
   */
  TMWTYPES_UCHAR  lastUnsolTxFragment[DNPCNFG_MAX_TX_FRAGMENT_LENGTH];
  TMWTYPES_UCHAR  lastTxFragment[DNPCNFG_MAX_TX_FRAGMENT_LENGTH];
#endif

#endif
} DNPCHNL;

#ifdef __cplusplus
extern "C" {
#endif

  /* function: dnpchnl_initConfig 
   * purpose: Initialize DNP3 channel configuration data structures. The
   *  user should call this routing to initialize these data structures
   *  and then modify the desired fields before calling dnpchnl_openChannel
   *  to actually open the desired channel.
   * arguments:
   *  pDNPConfig - pointer to DNP channel configuration, note that some
   *   parameters in this structure will override values in the transport,
   *   link, and physical layer configurations.
   *  pTprtConfig - pointer to transport layer configuration
   *  pLinkConfig - pointer to link layer configuration
   *  pPhysConfig - pointer to physical layer configuration
   * returns:
   *  void
   */
  TMWDEFS_SCL_API void TMWDEFS_GLOBAL dnpchnl_initConfig(
    DNPCHNL_CONFIG *pDNPConfig,
    DNPTPRT_CONFIG *pTprtConfig,
    DNPLINK_CONFIG *pLinkConfig, 
    TMWPHYS_CONFIG *pPhysConfig);

  /* function: dnpchnl_openChannel 
   * purpose: Open a DNP3 channel
   * arguments:
   *  pApplContext - application context to add channel to
   *  pDNPConfig - pointer to DNP channel configuration
   *  pTprtConfig - pointer to transport layer configuration
   *  pLinkConfig - pointer to link layer configuration
   *  pPhysConfig - pointer to physical layer configuration
   *  pIOConfig - pointer to target I/O configuration data structure
   *   which is passed directly to the target routines implemented
   *   in tmwtarg.h/c
   *  pTmwTargConfig - TMW specific IO configuration information 
   *   which will be passed to low level IO routines in tmwtarg.h.
   * returns:
   *  pointer to new channel, this pointer is used to reference this
   *  channel in other calls to the SCL.
   */
  TMWDEFS_SCL_API TMWCHNL * TMWDEFS_GLOBAL dnpchnl_openChannel(
    TMWAPPL *pApplContext,
    DNPCHNL_CONFIG *pDNPConfig,
    DNPTPRT_CONFIG *pTprtConfig,
    DNPLINK_CONFIG *pLinkConfig, 
    TMWPHYS_CONFIG *pPhysConfig,
    void *pIOConfig,
    struct TMWTargConfigStruct *pTmwTargConfig);

  /* function: dnpchnl_getChannelConfig  
   * purpose:  Get current configuration from an open channel
   * arguments:
   *  pSession - session to get configuration from
   *  pDNPConfig - dnp channel configuration data structure to be filled in
   *  pTprtConfig - transport configuration data structure to be filled in
   *  pLinkConfig - link configuration data structure to be filled in
   *  pPhysConfig - phys configuration data structure to be filled in
   * returns:
   *  TMWDEFS_TRUE if successful
   */
  TMWDEFS_SCL_API TMWTYPES_BOOL TMWDEFS_GLOBAL dnpchnl_getChannelConfig(
    TMWCHNL *pChannel,
    DNPCHNL_CONFIG *pDNPConfig,
    DNPTPRT_CONFIG *pTprtConfig,
    DNPLINK_CONFIG *pLinkConfig,
    TMWPHYS_CONFIG *pPhysConfig);

  /* function: dnpchnl_setChannelConfig 
   * purpose: Modify a currently open channel
   *  NOTE: normally dnpchnl_getChannelConfig() will be called
   *   to get the current config, some values will be changed 
   *   and this function will be called to set the values.
   * arguments:
   *  pChannel - channel to modify
   *  pDNPConfig - dnp channel configuration data structure
   *  pTprtConfig - transport layer configuration data structure
   *  pLinkConfig - link layer configuration data structure
   *  pPhysConfig - physical layer configuration data structure
   * returns:
   *  TMWDEFS_TRUE if successful
   */
  TMWDEFS_SCL_API TMWTYPES_BOOL TMWDEFS_GLOBAL dnpchnl_setChannelConfig(
    TMWCHNL        *pChannel,
    DNPCHNL_CONFIG *pDNPConfig,
    DNPTPRT_CONFIG *pTprtConfig,
    DNPLINK_CONFIG *pLinkConfig,
    TMWPHYS_CONFIG *pPhysConfig);

   /* function: dnpchnl_getBinFileChannelValues 
   * purpose: 
   * arguments:
   *  pDNPConfig - dnp channel configuration data structure
   *  pLinkConfig - link layer configuration data structure
   *  pPhysConfig - physical layer configuration data structure
   *  sessionIsOutstation - TMWDEFS_TRUE if session is outstation
   * returns:
   *  TMWDEFS_TRUE if successful
   */
  TMWTYPES_BOOL TMWDEFS_GLOBAL dnpchnl_getBinFileChannelValues(
    DNPCHNL_CONFIG *pDNPConfig,
    /*DNPTPRT_CONFIG *pTprtConfig,  */
    DNPLINK_CONFIG *pLinkConfig, 
    /*TMWPHYS_CONFIG *pPhysConfig,  */
    DNPBNCFG_FILEVALUES *binFileValues,
    TMWTYPES_BOOL sessionIsOutstation);

  /* function: dnpchnl_modifyPhys 
   *  DEPRECATED FUNCTION, SHOULD USE dnpchnl_setChannelConfig()
   */
  TMWTYPES_BOOL TMWDEFS_GLOBAL dnpchnl_modifyPhys(
    TMWCHNL *pChannel, 
    const TMWPHYS_CONFIG *pPhysConfig, 
    TMWTYPES_ULONG configMask);

  /* function: dnpchnl_modifyLink 
   *  DEPRECATED FUNCTION, SHOULD USE dnpchnl_setChannelConfig()
   */
  TMWTYPES_BOOL TMWDEFS_GLOBAL dnpchnl_modifyLink(
    TMWCHNL *pChannel, 
    const DNPLINK_CONFIG *pLinkConfig, 
    TMWTYPES_ULONG configMask);

  /* function: dnpchnl_modifyTprt 
   *  DEPRECATED FUNCTION, SHOULD USE dnpchnl_setChannelConfig()
   */
  TMWTYPES_BOOL TMWDEFS_GLOBAL dnpchnl_modifyTprt(
    TMWCHNL *pChannel, 
    const DNPTPRT_CONFIG *pTprtConfig, 
    TMWTYPES_ULONG configMask);

  /* function: dnpchnl_modifyChannel 
   *  DEPRECATED FUNCTION, SHOULD USE dnpchnl_setChannelConfig()
   */
  TMWTYPES_BOOL TMWDEFS_GLOBAL dnpchnl_modifyChannel(
    TMWCHNL *pChannel, 
    const DNPCHNL_CONFIG *pConfig, 
    TMWTYPES_ULONG configMask);

  /* function: dnpchnl_closeChannel 
   * purpose: Close a previously opened channel
   * arguments:
   *  pChannel - channel to close
   * returns:
   *  TMWDEFS_TRUE if successful, else TMWDEFS_FALSE
   */
  TMWDEFS_SCL_API TMWTYPES_BOOL TMWDEFS_GLOBAL dnpchnl_closeChannel(
    TMWCHNL *pChannel);

  /* function: dnpchnl_sendFragment
   * purpose: Sends a fragment to the designated channel or session
   * arguments:
   *  pTxData - fragment to send
   * returns:
   *  TMWDEFS_TRUE if fragment was successfully queued for transmission
   *  else TMWDEFS_FALSE
   * NOTE: if this function returns TMWDEFS_FALSE caller retains ownership of
   *  pTxData and should call dnpchnl_freeTxData to deallocate it.
   */
  TMWDEFS_SCL_API TMWTYPES_BOOL TMWDEFS_GLOBAL dnpchnl_sendFragment(
    TMWSESN_TX_DATA *pTxData);

  /* function: dnpchnl_cancelFragment
   * purpose: Cancel a previously sent fragment.
   * arguments:
   *  pTxData - fragment to cancel
   * returns:
   *  TMWDEFS_TRUE if fragment was cancelled, else TMWDEFS_FALSE
   */
  TMWDEFS_SCL_API TMWTYPES_BOOL TMWDEFS_GLOBAL dnpchnl_cancelFragment(
    TMWSESN_TX_DATA *pTxData);

  /* function: dnpchnl_deleteFragments 
   * purpose: Remove any outstanding fragments on the channel for this session
   * arguments:
   *  pSession - pointer to session to remove fragments for
   * returns:
   *  void
   */
  TMWDEFS_GLOBAL void dnpchnl_deleteFragments(
    TMWSESN *pSession);

  /* function: dnpchnl_okToSend
   * purpose: Tell the dnp channel it is now OK to send requests
   * arguments:
   *  pChannel - pointer to channel
   * returns:
   *  void
   */
  void TMWDEFS_GLOBAL dnpchnl_okToSend(
    TMWCHNL *pChannel);

  /* function: dnpchnl_checkForChannelIdle
   * purpose: Determine if channel is idle or if it currently
   *  has something to send or is expecting a response. If it is
   *  idle and there is an idle callback registered it will be called.
   * arguments:
   *  pChannel - channel to check for idle
   * returns:
   *  void
   */
  void TMWDEFS_GLOBAL dnpchnl_checkForChannelIdle(
    TMWCHNL *pChannel);

  /* function: dnpchnl_userCallback   
   * purpose: Call user callback function if one has been specified for
   *  this request
   * arguments:
   *  pChannel - channel data will be transmitted on
   *  pTxData - request
   *  pResponse - response information for this request
   * returns:
   *  void
   */
  TMWDEFS_GLOBAL void dnpchnl_userCallback(
    TMWCHNL *pChannel,
    DNPCHNL_TX_DATA *pTxData, 
    DNPCHNL_RESPONSE_INFO *pResponse);

  /* function: dnpchnl_newTxData
   * purpose: Allocate a new transmit data structure to hold a fragment
   *  to be transmitted
   * arguments:
   *  pChannel - channel data will be transmitted on
   *  pSession - session data will be transmitted to or TMWDEFS_NULL if
   *   message is a broadcast message
   *  size - number of bytes in message
   *  destAddress - destination address 
   * returns:
   *  allocated transmit data structure
   */
  TMWDEFS_SCL_API TMWSESN_TX_DATA * TMWDEFS_GLOBAL dnpchnl_newTxData(
    TMWCHNL *pChannel, 
    TMWSESN *pSession, 
    TMWTYPES_USHORT size,
    TMWTYPES_USHORT destAddress);

  /* function: dnpchnl_freeTxData
   * purpose: Free transmit data structure previously. This routine will
   *  generally be called by the SCL and should not be called by the user
   *  unless a previously allocated transmit data structure is canceled
   *  before it is passed to the SCL.
   * arguments:
   *  pTxData - transmit data structure to free
   * returns:
   *  void
   */
  TMWDEFS_SCL_API void TMWDEFS_GLOBAL dnpchnl_freeTxData(
    TMWSESN_TX_DATA *pTxData);

  /* function: dnpchnl_processFragment
   * purpose: Process received fragment 
   * arguments:
   *  pSession - pointer to session
   *  pRxFragment - pointer to received fragment
   * returns:
   *  void
   */
  TMWDEFS_SCL_API void TMWDEFS_CALLBACK dnpchnl_processFragment(
    TMWSESN *pSession, 
    TMWSESN_RX_DATA *pRxFragment);

#ifdef __cplusplus
}
#endif
#endif /* DNPCHNL_DEFINED */
